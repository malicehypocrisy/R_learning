# 一、向量

> [!IMPORTANT]
>
> ==元素的数据类型是统一的，可以是整形，数值型（浮点数），字符型（字符串），逻辑型，复数型等等。==
>
> 所有R对象都有其属性，其最重要的两个属性:**_<u>类型(typeof(x))与长度(length(x)。</u>_**
>
> length()获取向量长度。

##  1. 基础

​	&#9312;标量：单个数值是向量的一种特例。

​	&#9313;**向量的索引从1开始，连续存储，不能插入或删除，若要添加或删除元素，重新给向量赋值。**

```R
x<-c(88,5,12,13)
#将168插到13的前面
x<-c(x[1:3],168，x[4])
```

## 2. 自动补齐

**在要求这两个向量具有相同的长度，R会自动重复较短的向量，直到它与另外一个向量长度匹配**

```R
#矩阵在R中按列存储
> x<-matrix(c(1,2,3,4,5,6),nrow=3)
> View(x)
> x+c(1,2)
     [,1] [,2]
[1,]    2    6
[2,]    4    6
[3,]    4    8
```

$$
x+c(1,2)=\begin{bmatrix}
1 & 4 \\
2 & 5 \\
3 & 6 \\
\end{bmatrix}+\begin{bmatrix}
1 & 2 \\
2 & 1 \\
1 & 2 \\
\end{bmatrix}
$$

##  3. 常用操作

### &#9312;向量运算与逻辑运算

* \+、*、/、-、%/%（求商）和%%（取余）按元素逐一进行运算

* \内积：%*%

* \^将第二向量作为第一向量的指数

### &#9313;向量索引

* 语法：向量1[向量2]#向量1中索引为向量2的那些元素

  - 元素允许重复
  - 负数下标表示删除相应元素

### &#9313;用:运算符创建向量

```R
#创建5 6 7 8
5：8
```

### &#9314;使用seq()创建向量

```R
#生成等差数列
seq(from=12,to=30,by=3)
#seq(x)等价于1：length(x)
for(i in seq(x))
```

### &#9315;聚合成新向量

​	c()连接两个向量名

### &#9316;向量元素命名

```R
x<-c("a"=5,"b"=6)
> x<-c(5,6)
names(x)<-c("a","b")
#把向量元素名称赋值为NULL，可以移除元素名称
#可以通过名称引用向量中元素
> x["b"]
```

### &#9317;使用rep()重复向量常数

```R
#创建times*length(x)个元素向量，这个向量由x重复times次构成。
#另外一个each参数表示向量x交替重复的次数.
rep(x,times）
```

### &#9317;使用all()和any()

* __报告其参数至少有一个或全部为TRUE__

* ==cumsum()向量累加和==

### &#9318;选择函数which()

​	找到满足条件元素的位置

### 3.向量化运算

***应用到向量上函数实际上应用到每一个元素上***

### &#9312;向量输入、向量输出

* +算子、*算子、内置函数、超越函数（平方根、对数、三角函数等）

* round（）函数四舍五入得到最近整数

### &#9313;sapply(x,f)函数

​	对x的每一个元素使用函数f(),并将结果__转化为矩阵r语言__。

### &#9314;ifelse(b,u,v)

* b是一个布尔值向量，u和v是向量

* 该元素返回的值也是向量，如果b[i]为真，则返回第i个元素为u[i],反之返回第i个元素为v[i]

# 二、因子

> [!IMPORTANT]
>
> ==因子对应为分类==

```R
library(forcats)
```

## 1. 因子与水平

```R
x<-c(5,12,13,12)
#xf中不同的数值（5，12，13）就是水平
#数据是由水平1的值，接着水平2的值和水平3的值，最后是水平2的值构成
xf<-factor(x)
#插入新的水平
xff<-factor(x,levels=c(5,12,13,88))
```

&#9312;不属于因子层级中的值，会被当做缺省值NA

&#9313;调整因子顺序

```R
x %>% fct_relevel(c("high","medium","low"))
```

## 2. 常用函数

### &#9312;tapply函数

```R
ages<-c(25,26,55,37,21,42)
affils<-c("R","D","D","R","U","D")
tapply(ages,affils,mean)
D  R  U 
41 31 21 
```

​	(1)tapply(x,f,g)需要向量x,因子或因子列表f以及函数g

​	(2)as.factor()强制转化为因子

### &#9313;split()函数

​	split(x,f)x为向量或数据框，f为因子或因子的列表.将x分组，并返回分组的列表

```R
f <- factor(c("A", "A", "B", "B", "C", "C"), levels = c("A", "B", "C", "D"))
# 创建一个向量
x <- c(1, 2, 3, 4, 5, 6)
# 使用 split 函数，drop = TRUE
result <- split(x, f, drop = TRUE)
result
$A
[1] 1 2
$B
[1] 3 4
$C
[1] 5 6
```

### &#9314;by()函数

```R
> # 使用 by 函数计算每个分组的均值
> result <- by(df$value, df$group, mean)
> # 查看结果
> print(result)
df$group: A
[1] 15
------------------------------------------------------------- 
df$group: B
[1] 35
------------------------------------------------------------- 
df$group: C
[1] 55
```

​	第一个参数指定数据，第二个为分组因子，最后应用于每组的函数.

# 三、列表

> [!IMPORTANT]
>
> 组合不同类型的对象
>
> 每列不均一

## 1. 创建列表

```R
#列表各组件的名称叫标签，标签是可选的，也可以不指定（不推荐）
#$使用标签的名字可以简写，只要写出前几个字母，只要不引起歧义
z<-vector(mode="list")
list1 <- list( a = c(5, 10), b = c("I", "love", "R", "language", "!"), c = c(TRUE, TRUE, FALSE, TRUE))
```

## 2. 常用函数

```R
#对1：3，25：29执行mddian函数，返回一个列表
lapply(list(1:3,25:29),median)
#对1：3，25：29执行mddian函数，返回矩阵或向量形式
sapply(list(1:3,25;29),median)
```

## 3. 递归列表

​	&#9312;列表的组件也可以是列表

​	&#9313;拼接函数c()有一个可选参数recursive,可以将所有组件的元素都提取出来，组成一个向量，默认值为FALSE

## 4. 列表操作

### &#9312;列表索引

```R
#双方括号一次只能提取一个元素，返回的是组件本身的类型
1st$c
1st[["c"]]
1st[[i]]
#只提取一个元素，返回的仍然是一个列表，而不是元素本身
1st["c"]
1st[i]
```

### &#9313;访问列表元素和值

​	(1) names()获取它的标签

​	(2) unlist()获取列表的值，返回的值是一个向量

### &#9314;去除名字

```R
names(wu)<-NULL
#函数去掉元素名
unnames()
```

# 四、数据框

> [!IMPORTANT]
>
> 数据框类似矩阵，由行和列两个维度，但数据框的每一列可以是不同的模式
>
> data.frame转换为tibble的方法：as_tibble()
>
> ```R
> #创建tibble
> library(tidyverse)
> ```

## 1. 创建数据框

```R
#用kids和ages这两个向量来生成一个数据框
kids<-c('Jack','Jill')
ages<-c(12,10)
d<-data.frame(kids,ages)
#创建tibble
td<-tibble::tribble(~day,~price,1,"30-45",2,"40-95",3,"89-65",4,"45-63",5,"52-42")
tibble(a = 1:5,b = letters[1:5])
```

## 2. 访问数据框

&#9312;访问数据框

&#9313;可以使用列表的组件的索引值或者组件d$kids

&#9314;使用矩阵的方式来访问

## 3.操作

### &#9312;提取

```R
#设定参数drop=FALSE,可以得到数据框，否则得到向量
b[2:5,2,drop=FALSE]
#筛选
b[b$c>=3.8]
```

### &#9313;缺失值处理

```R
#来告诉R忽略缺失值
na.rm=TRUE
#筛选数据框b中c列中数据大于3.8
subset(b,c>=3.8)
#数据框中NA为FALSE,否则为TRUE
complete.cases()
```

### &#9314;rbind()和cbind()函数

​	前提：两个数据框有相同的行数或者列数

### &#9315;apply()函数

```R
apply(examsquiz,1,max)
```

### &#9316;合并

```R
#将数据框x和y合并
merge(x,y)
```

### &#9316;lapply()和sapply()函数

  	f()函数会作用于数据框的每一列，然后返回值置于列表中，使用as.data.frame()转化为数据框。

## 4. tibble使用

```R
#增加列
add_column(df,z=0:1,w=0)
#增加行
#在第二行增加一行，.before可省，默认在最后面增加
add_row(df,x=99,y=9,.before=2)
```

### &#9312;lst()具有tibble特性

```R
lst(n=5,x=runif(n),y=TRUE)
```

### &#9313;enframe()函数

​	创建的tibble只有2列：name和value

### &#9314;deframe()函数

​	将tibble反转为向量

### &#9315;read_csv()

​	读取文件直接生成tibble

### &#9316;set_names()

​	为列设置名字

### &#9317;tibble没有行名

```R
#若要保存行名，就需要把行名转换单独保存一行
rownames_to_column(df, var = "rowname")
rowid_to_column(df, var = "rowid")
```

### &#9318;查看缺失值

```R
summarise_all(~sum(is.na(.))
map_df(~sum(is.na(.)))
```

# 五、矩阵

> [!IMPORTANT]
>
> 矩阵的行与列下标都是从1开始, **储存是按列储存**,将matrix (   ) 属性==byrow设为TRUE后元素按行排列==。

```R
#创建矩阵方法一
y<-matrix(c(1,2,3,4),nrow=2,ncol=2)
#创建矩阵方法二
y<-matrix(nrow=2,nco1=2)
#赋值
y[2,2]<-4
# 打印第二列元素
y[,2]
```

## 1. 一般矩阵运算

&#9312; 线性代数运算 

​	(1)__%*%__矩阵乘法 

​	(2) __*__逐个元素相乘 

​	(3)__+__矩阵相加

 &#9313; 矩阵索引 

```R
#提取矩阵第2列和第3列
z[,2:3]
#对y的第1、3行赋了新值。
y[c(1,3),]<-matrix(c(1,1,8,12),ncol=2)
#负值索表示删除第二行
y[-2,]
```

&#9314; 矩阵元素筛选

```R
#除去小于3的行
x[x[,2]>=3,]
x[z%%2==1,]
```

&#9315;rbind(   )函数按行组合与cbind(   )按列组合可以给矩阵增加行或列代

```R
z<-matrix(c(1,2,3,4,5,6,7,8,9,0),ncol=5)
> View(z)
> cbind(z,1)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9    1
[2,]    2    4    6    8    0    1
```

&#9316;col (   ) 返回矩阵元素的列号,row(   )返回元素行号。

## 2. 常用函数

### &#9312;使用apply(   )函数

* 语法：apply ( m, dimcode, f, fargs)。

​		其中，m为矩阵；dimcode维度编号（__1__为行，__2__为列）；f函数；fargs是可选数据集；默认按列输出。

### &#9313;.矩阵的属性

* length(   ) 长度

* dim.(   )行列属性

* ncol(   )与nrow(   )行数与列数

### &#9314; 避免意外降维

* .__提取子阵时加上参数drop=FALSE参数防止降维__

* ’['(z,3,2) # 等价于 z [3,2]

* ***as.matrix()函数将其他转化为矩阵***

### &#9316;高维数组

```R
#第二个2表示数据有层，每层三行两列，这个参数会形成数组dim属性（用$dim)
tests<-array(data=c(),dim=c(3,2,2))
```

