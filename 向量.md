> [!IMPORTANT]
>
> ==元素的数据类型是统一的，可以是整形，数值型（浮点数），字符型（字符串），逻辑型，复数型等等。==
>
> 所有R对象都有其属性，其最重要的两个属性:**_<u>类型(typeof(x))与长度(length(x)</u>_**
>
> length()获取向量长度

#  一、 基础

## 1..c()

* 连接向量与标量

## 2.用:运算符创建向量

```R
#创建5 6 7 8
5：8
```

## 3.运算

* \+、*、/、-、%/%（求商）和%%（取余）按元素逐一进行运算

* \内积：%*%

* \^将第二向量作为第一向量的指数

## 4.向量索引

* 语法：**向量1[向量2]**#向量1中索引为向量2的那些元素

	&#9332;元素允许重复

	&#9333;负数下标表示删除相应元素

* 通过名称索引：x["b"]

* **向量的索引从1开始，连续存储，不能插入或删除，若要添加或删除元素，重新给向量赋值。**

```R
x<-c(88,5,12,13)
#将168插到13的前面
x<-c(x[1:3],168，x[4])
```

## 5.向量元素命名

```R
x<-c("a"=5,"b"=6)
x<-c(5,6)
names(x)<-c("a","b")
```

* 把向量元素名称赋值为NULL，可以移除元素名称

# 二、自动补齐

**在要求这两个向量具有相同的长度，R会自动重复较短的向量，直到它与另外一个向量长度匹配**

```R
#矩阵在R中按列存储
> x<-matrix(c(1,2,3,4,5,6),nrow=3)
> View(x)
> x+c(1,2)
     [,1] [,2]
[1,]    2    6
[2,]    4    6
[3,]    4    8
```

$$
x+c(1,2)=\begin{bmatrix}
1 & 4 \\
2 & 5 \\
3 & 6 \\
\end{bmatrix}+\begin{bmatrix}
1 & 2 \\
2 & 1 \\
1 & 2 \\
\end{bmatrix}
$$

# 三、常用函数

## 1.使用seq()创建向量

```R
#生成等差数列
seq(from=12,to=30,by=3)
#seq(x)等价于1：length(x)
for(i in seq(x))
```

## 2.使用rep()重复向量常数

```R
s2<-rep(x=c(0,1),times=3)
s2
##[1]0 1 0 1 0 1
```

```R
s2<-rep(x=c(0,1),each=3)
s2
##[1]0 1 0 1 0 1
```

## 3.使用all()和any()

* __报告其参数至少有一个或全部为TRUE__

* ==cumsum()向量累加和==

## 4.选择函数which()

* 找到满足条件元素的位置

# 四、因子型向量

> [!IMPORTANT]
>
> ==因子对应为分类==

```R
library(forcats)
```

## 1. 因子与层级

```R
x<-c(5,12,13,12)
#xf中不同的数值（5，12，13）就是水平
#数据是由水平1的值，接着水平2的值和水平3的值，最后是水平2的值构成
xf<-factor(x)
#插入新的水平
xff<-factor(x,levels=c(5,12,13,88))
```

&#9312;不属于因子层级中的值，会被当做缺省值NA

&#9313;调整因子顺序

```R
soldier <-factor(c("Colobel","General","Captain"),levels=c("General","Colonel","Captain"))
```

## 2. 常用函数

### &#9312;tapply函数

```R
ages<-c(25,26,55,37,21,42)
affils<-c("R","D","D","R","U","D")
tapply(ages,affils,mean)
D  R  U 
41 31 21 
```

&#9332;tapply(x,f,g)需要向量x,因子或因子列表f以及函数g

&#9333;as.factor()强制转化为因子

### &#9313;split()函数

​	split(x,f)x为向量或数据框，f为因子或因子的列表.将x分组，并返回分组的列表

```R
f <- factor(c("A", "A", "B", "B", "C", "C"), levels = c("A", "B", "C", "D"))
# 创建一个向量
x <- c(1, 2, 3, 4, 5, 6)
# 使用 split 函数，drop = TRUE
result <- split(x, f, drop = TRUE)
result
$A
[1] 1 2
$B
[1] 3 4
$C
[1] 5 6
```

### &#9314;by()函数

```R
> # 使用 by 函数计算每个分组的均值
> result <- by(df$value, df$group, mean)
> # 查看结果
> print(result)
df$group: A
[1] 15
------------------------------------------------------------- 
df$group: B
[1] 35
------------------------------------------------------------- 
df$group: C
[1] 55
```

​	第一个参数指定数据，第二个为分组因子，最后应用于每组的函数.

# 三、列表

> [!IMPORTANT]
>
> 

## 1. 创建列表

```R
#列表各组件的名称叫标签，标签是可选的，也可以不指定（不推荐）
#$使用标签的名字可以简写，只要写出前几个字母，只要不引起歧义
z<-vector(mode="list")
list1 <- list( a = c(5, 10), b = c("I", "love", "R", "language", "!"), c = c(TRUE, TRUE, FALSE, TRUE))
```

## 2. 常用函数

```R
#对1：3，25：29执行mddian函数，返回一个列表
lapply(list(1:3,25:29),median)
#对1：3，25：29执行mddian函数，返回矩阵或向量形式
sapply(list(1:3,25;29),median)
```

## 3. 递归列表

​	&#9312;列表的组件也可以是列表

​	&#9313;拼接函数c()有一个可选参数recursive,可以将所有组件的元素都提取出来，组成一个向量，默认值为FALSE

## 4. 列表操作

### &#9312;列表索引

```R
#双方括号一次只能提取一个元素，返回的是组件本身的类型
1st$c
1st[["c"]]
1st[[i]]
#只提取一个元素，返回的仍然是一个列表，而不是元素本身
1st["c"]
1st[i]
```

### &#9313;访问列表元素和值

&#9332; names()获取它的标签

&#9333;unlist()获取列表的值，返回的值是一个向量

### &#9314;去除名字

```R
names(wu)<-NULL
#函数去掉元素名
unnames()
```

# 四、数据框

> [!IMPORTANT]
>
> 数据框类似矩阵，由行和列两个维度，但数据框的每一列可以是不同的模式
>
> data.frame转换为tibble的方法：as_tibble()
>
> ```R
> #创建tibble
> library(tidyverse)
> ```

## 1. 创建数据框

```R
#用kids和ages这两个向量来生成一个数据框
kids<-c('Jack','Jill')
ages<-c(12,10)
d<-data.frame(kids,ages)
#创建tibble
td<-tibble::tribble(~day,~price,1,"30-45",2,"40-95",3,"89-65",4,"45-63",5,"52-42")
tibble(a = 1:5,b = letters[1:5])
```

## 2. 访问数据框

&#9312;访问数据框

&#9313;可以使用列表的组件的索引值或者组件d$kids

&#9314;使用矩阵的方式来访问

## 3.操作

### &#9312;提取

```R
#设定参数drop=FALSE,可以得到数据框，否则得到向量
b[2:5,2,drop=FALSE]
#筛选
b[b$c>=3.8]
```

### &#9313;缺失值处理

```R
#来告诉R忽略缺失值
na.rm=TRUE
#筛选数据框b中c列中数据大于3.8
subset(b,c>=3.8)
#数据框中NA为FALSE,否则为TRUE
complete.cases()
```

### &#9314;rbind()和cbind()函数

​	前提：两个数据框有相同的行数或者列数

### &#9315;apply()函数

```R
apply(examsquiz,1,max)
```

### &#9316;合并

```R
#将数据框x和y合并
merge(x,y)
```

### &#9316;lapply()和sapply()函数

  	f()函数会作用于数据框的每一列，然后返回值置于列表中，使用as.data.frame()转化为数据框。

## 4. tibble使用

```R
#增加列
add_column(df,z=0:1,w=0)
#增加行
#在第二行增加一行，.before可省，默认在最后面增加
add_row(df,x=99,y=9,.before=2)
```

### &#9312;lst()具有tibble特性

```R
lst(n=5,x=runif(n),y=TRUE)
```

### &#9313;enframe()函数

​	创建的tibble只有2列：name和value

### &#9314;deframe()函数

​	将tibble反转为向量

### &#9315;read_csv()

​	读取文件直接生成tibble

### &#9316;set_names()

​	为列设置名字

### &#9317;tibble没有行名

```R
#若要保存行名，就需要把行名转换单独保存一行
rownames_to_column(df, var = "rowname")
rowid_to_column(df, var = "rowid")
```

### &#9318;查看缺失值

```R
summarise_all(~sum(is.na(.))
map_df(~sum(is.na(.)))
```



