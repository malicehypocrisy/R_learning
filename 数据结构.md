# 一、矩阵

> [!IMPORTANT]
>
> * 矩阵的行与列下标都是从1开始, **储存是按列储存**
>
> * 将matrix (   ) 属性==byrow设为TRUE后元素按行排列==。
>
> ```R
> #创建矩阵方法一
> y<-matrix(c(1,2,3,4),nrow=2,ncol=2)
> #创建矩阵方法二
> y<-matrix(nrow=2,nco1=2)
> #赋值
> y[2,2]<-4
> # 打印第二列元素
> y[,2]
> ```
>

##  1.矩阵运算

### &#9312; 线性代数运算 

* __%*%__乘 ;__*__逐个元素相乘 __+__矩阵相加

##  &#9313; 索引 

```R
#提取矩阵第2列和第3列
z[,2:3]
#对y的第1、3行赋了新值。
y[c(1,3),]<-matrix(c(1,1,8,12),ncol=2)
#负值索表示删除第二行
y[-2,]
```

&#9314;rbind(   )函数

* 按行组合增加行

&#9315;cbind(   )

* 按列组合可以给矩阵增加列

```R
z<-matrix(c(1,2,3,4,5,6,7,8,9,0),ncol=5)
> View(z)
> cbind(z,1)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9    1
[2,]    2    4    6    8    0    1
```



## 2. 常用函数

### &#9312;使用apply(   )函数

* 语法：apply ( m, dimcode, f, fargs)。

​		其中，m为矩阵；dimcode维度编号（__1__为行，__2__为列）；f函数；fargs是可选数据集；默认按列输出。

### &#9313;.矩阵的属性

* length(   ) 长度

* dim.(   )行列属性

* ncol(   )与nrow(   )行数与列数

### &#9314; 避免意外降维

* .__提取子阵时加上参数drop=FALSE参数防止降维__

* ’['(z,3,2) # 等价于 z [3,2]

* ***as.matrix()函数将其他转化为矩阵***

### &#9315;高维数组

```R
#第二个2表示数据有层，每层三行两列，这个参数会形成数组dim属性（用$dim)
tests<-array(data=c(),dim=c(3,2,2))
```

# 二、列表

> [!CAUTION]
>
> 组合不同类型的对象
>
> 每列不均一

1.创建列表

```R
#列表各组件的名称叫标签，标签是可选的，也可以不指定（不推荐）
#$使用标签的名字可以简写，只要写出前几个字母，只要不引起歧义
z<-vector(mode="list")
list1 <- list( a = c(5, 10), b = c("I", "love", "R", "language", "!"), c = c(TRUE, TRUE, FALSE, TRUE))
```

2.常用函数

```R
#对1：3，25：29执行mddian函数，返回一个列表
lapply(list(1:3,25:29),median)
#对1：3，25：29执行mddian函数，返回矩阵或向量形式
sapply(list(1:3,25;29),median)
```

## 3. 递归列表

​	&#9312;列表的组件也可以是列表

​	&#9313;拼接函数c()有一个可选参数recursive,可以将所有组件的元素都提取出来，组成一个向量，默认值为FALSE

4.列表索引

```R
#双方括号一次只能提取一个元素，返回的是组件本身的类型
1st$c
1st[["c"]]
1st[[i]]
#只提取一个元素，返回的仍然是一个列表，而不是元素本身
1st["c"]
1st[i]
```

